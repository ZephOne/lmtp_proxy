#!/bin/env python
#
# A simple LMTP delivery proxy
#
# 2017 Andreas Thienemann <andreas@bawue.net>
# 2022 ZephOne <zephone@protonmail.com>
# Licensed under GPLv3+
# https://github.com/ixs/lmtp_proxy
#

import argparse
import asyncio
import grp
import os
import pwd
import signal
import smtplib
import syslog

from aiosmtpd.controller import Controller, UnixSocketController
from aiosmtpd.handlers import Proxy
from aiosmtpd.lmtp import LMTP
import yaml


class LMTPController(Controller):
    """Controller for LMTP usage"""

    def factory(self):
        return LMTP(self.handler, **self.SMTP_kwargs)


class UnixSocketLMTPController(UnixSocketController):
    """UnixSocketController for LMTP usage"""

    def factory(self):
        return LMTP(self.handler, **self.SMTP_kwargs)


class LMTPProxy(Proxy):
    def __init__(self):
        self.config = None
        self.options = {}

    def log(self, message):
        syslog.syslog(syslog.LOG_INFO, message)

    def lookup_user_backend(self, user):
        backend = self.config["users"].get(
            user, self.config["config"].get("fallback_backend", None)
        )
        if backend is None:
            raise RuntimeError("No fallback backend configured")
        return backend

    def lookup_user(self, rcpt_to):
        local_part_suffix = self.config["config"].get("localPartSuffix", False)

        user = rcpt_to
        if local_part_suffix:
            login = user.split(local_part_suffix)[0]
            domain = user.split("@")[1]
            user = f"{login}@{domain}"
        if self.config["config"].get("ignoreDomain", False):
            user = user.split("@")[0]
        return user

    def _deliver(self, mail_from, rcpt_tos, data):
        """Overide aiosmtpd.handlers.Proxy._deliver to use an LMTP client"""
        refused = {}

        user = self.lookup_user(rcpt_tos[0])

        backend = self.lookup_user_backend(user)

        if backend == "reject":
            self.log(
                f"LMTP message from <{mail_from}> to <{rcpt_tos[0]}> temporarily rejected"
            )
            return f"450 LMTP user {rcpt_tos} rejected. Please try again."

        backend_data = self.config["backends"].get(backend, None)
        if backend_data is None:
            self.log(f"No backend configuration found for backend {backend}")
            return f"451 No backend configuration found for backend {backend}"

        try:
            lmtp_client = smtplib.LMTP()
            lmtp_client.connect(backend_data["host"], backend_data["port"])
            try:
                refused = lmtp_client.sendmail(mail_from, user, data)
                self.log(
                    f"LMTP message from <{mail_from}> to <{user}> delivered to {backend}"
                )
            finally:
                lmtp_client.quit()
        except smtplib.SMTPRecipientsRefused as recipients_refused_error:
            self.log("got SMTPRecipientsRefused")
            refused = recipients_refused_error.recipients
        except (OSError, smtplib.SMTPException) as lmtp_send_error:
            self.log(f"got {lmtp_send_error.__class__}")
            errcode = getattr(lmtp_send_error, "smtp_code", -1)
            errmsg = getattr(lmtp_send_error, "smtp_error", b"ignore")
            for rcpt_to in rcpt_tos:
                refused[rcpt_to] = (errcode, errmsg)
        return refused

    def reload_user_list(self):
        try:
            with open(self.options["config"]) as f:
                self.config = yaml.safe_load(f)
            self.log(
                f"Userlist reloaded. {len(self.config.get('users', {}))} Entries found"
            )
        except:
            pass


def parse_cmdline():
    parser = argparse.ArgumentParser(
        description="""An LMTP Proxy server. Accepts mail via LMTP on an incoming
            socket and can forward to different lmtp sockets depending on the
            destination address."""
    )
    parser.add_argument(
        "-c",
        "--config",
        help="Configuration file location",
        nargs="?",
        default="/etc/lmtp-proxy.conf",
    )
    return parser.parse_args()


def parse_config(file):
    with open(file) as f:
        config = yaml.safe_load(f)
    return config


def configure_unix_socket(address, owner, group, permissions):
    try:
        os.unlink(address)
    except OSError:
        if os.path.exists(address):
            raise
    if owner is not None:
        os.chown(address, pwd.getpwnam(owner).pw_uid, -1)
    if group is not None:
        os.chown(address, -1, grp.getgrnam(owner).gr_gid)
    if permissions is not None:
        os.chmod(address, permissions)


async def main(loop):
    options = parse_cmdline()
    config = parse_config(options.config)
    tmp = {"config": options.config}

    syslog.openlog(
        ident="lmtp-proxy", logoption=syslog.LOG_PID, facility=syslog.LOG_MAIL
    )
    syslog.syslog(syslog.LOG_INFO, f"Started using configuration file {options.config}")

    address = config["config"].get("socket", False)
    owner = config["config"].get("owner", None)
    group = config["config"].get("group", None)
    permissions = config["config"].get("permissions", None)

    lmtp_handler = LMTPProxy()
    lmtp_handler.config = config
    lmtp_handler.options = tmp

    if address[0] == "/":
        configure_unix_socket(address, owner, group, permissions)
        controller = UnixSocketLMTPController(lmtp_handler, unix_socket=address)
        address_text = address
    else:
        address = tuple(address)
        address_text = f"{address[0]}:{address[1]}"
        controller = LMTPController(lmtp_handler, hostname=address[0], port=address[1])

    signal.signal(signal.SIGUSR1, lmtp_handler.reload_user_list)
    signal.signal(signal.SIGTERM, controller.stop)

    lmtp_handler.log(f"Listening for incoming connection on {address_text}")
    controller.start()


if __name__ == "__main__":
    loop = asyncio.new_event_loop()
    loop.create_task(main(loop=loop))
    try:
        loop.run_forever()
    except KeyboardInterrupt:
        pass
